"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _reactNative = require("react-native");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function convertErrors(errs) {
  if (!errs) {
    return null;
  }

  return Array.isArray(errs) ? errs.filter(e => !!e) : [errs];
}

function checkValidInput(usedKey, value) {
  const isValuePassed = arguments.length > 1;

  if (typeof usedKey !== 'string') {
    console.warn(`[AsyncStorageLegacy] Using "${typeof usedKey}" type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\nKey passed: ${usedKey}\n`);
  }

  if (isValuePassed && typeof value !== 'string') {
    if (value == null) {
      throw new Error(`[AsyncStorageLegacy] Passing "null" or "undefined" as value is not supported. If you need to remove a value, use ".removeSingle" method instead.\nUsed key: ${usedKey}\n`);
    } else {
      console.warn(`[AsyncStorageLegacy] The value for key "${usedKey}" is not a string. This can lead to unexpected behavior/errors. Consider stringifying it.\nPassed value: ${value}\nPassed key: ${usedKey}\n`);
    }
  }
}

class LegacyAsyncStorage {
  constructor() {
    _defineProperty(this, "_asyncStorageNativeModule", void 0);

    this._asyncStorageNativeModule = _reactNative.NativeModules.RNC_AsyncSQLiteDBStorage || _reactNative.NativeModules.RNCAsyncStorage;

    if (!this._asyncStorageNativeModule) {
      throw new Error('[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null.');
    }
  }

  async getSingle(key, _) {
    checkValidInput(key);
    return new Promise((resolve, reject) => {
      this._asyncStorageNativeModule.multiGet([key], function (errors, result) {
        const value = result && result[0] && result[0][1] || null;
        const errs = convertErrors(errors);

        if (errs && errs.length) {
          reject(errs[0]);
        } else {
          resolve(value);
        }
      });
    });
  }

  async setSingle(key, value, _) {
    checkValidInput(key, value);
    return new Promise((resolve, reject) => {
      this._asyncStorageNativeModule.multiSet([[key, value]], function (errors) {
        const errs = convertErrors(errors);

        if (errs && errs.length) {
          reject(errs[0]);
        } else {
          resolve();
        }
      });
    });
  }

  async getMany(keys, _) {
    keys.forEach(k => checkValidInput(k));
    return new Promise((resolve, reject) => {
      this._asyncStorageNativeModule.multiGet(keys, function (errors, result) {
        const value = result.reduce((acc, current) => {
          const key = current[0];
          const val = current[1];
          return _objectSpread({}, acc, {
            [key]: val
          });
        }, {});
        const errs = convertErrors(errors);

        if (errs && errs.length) {
          reject(errs[0]);
        } else {
          resolve(value);
        }
      });
    });
  }

  async setMany(values, _) {
    values.forEach(keyValue => {
      Object.keys(keyValue).forEach(key => {
        checkValidInput(key, keyValue[key]);
      });
    });
    return new Promise((resolve, reject) => {
      const valuesArray = values.map(entry => {
        const key = Object.keys(entry)[0];
        const value = entry[key];
        return [key, value];
      });

      this._asyncStorageNativeModule.multiSet(valuesArray, function (errors) {
        const errs = convertErrors(errors);

        if (errs && errs.length) {
          reject(errs[0]);
        } else {
          resolve();
        }
      });
    });
  }

  async removeSingle(key, _) {
    checkValidInput(key);
    return new Promise((resolve, reject) => {
      this._asyncStorageNativeModule.multiRemove([key], function (errors) {
        const errs = convertErrors(errors);

        if (errs && errs.length) {
          reject(errs[0]);
        } else {
          resolve();
        }
      });
    });
  }

  async removeMany(keys, _) {
    keys.forEach(k => checkValidInput(k));
    return new Promise((resolve, reject) => {
      this._asyncStorageNativeModule.multiRemove(keys, function (errors) {
        const errs = convertErrors(errors);

        if (errs && errs.length) {
          reject(errs[0]);
        } else {
          resolve();
        }
      });
    });
  }

  async getKeys(_) {
    return new Promise((resolve, reject) => {
      this._asyncStorageNativeModule.getAllKeys(function (errors, keys) {
        const err = convertErrors(errors);

        if (err && err.length) {
          reject(err[0]);
        } else {
          resolve(keys);
        }
      });
    });
  }

  async dropStorage(_) {
    return new Promise((resolve, reject) => {
      this._asyncStorageNativeModule.clear(function (error) {
        const err = convertErrors(error);

        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

}

exports.default = LegacyAsyncStorage;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJjb252ZXJ0RXJyb3JzIiwiZXJycyIsIkFycmF5IiwiaXNBcnJheSIsImZpbHRlciIsImUiLCJjaGVja1ZhbGlkSW5wdXQiLCJ1c2VkS2V5IiwidmFsdWUiLCJpc1ZhbHVlUGFzc2VkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY29uc29sZSIsIndhcm4iLCJFcnJvciIsIkxlZ2FjeUFzeW5jU3RvcmFnZSIsImNvbnN0cnVjdG9yIiwiX2FzeW5jU3RvcmFnZU5hdGl2ZU1vZHVsZSIsIk5hdGl2ZU1vZHVsZXMiLCJSTkNfQXN5bmNTUUxpdGVEQlN0b3JhZ2UiLCJSTkNBc3luY1N0b3JhZ2UiLCJnZXRTaW5nbGUiLCJrZXkiLCJfIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJtdWx0aUdldCIsImVycm9ycyIsInJlc3VsdCIsInNldFNpbmdsZSIsIm11bHRpU2V0IiwiZ2V0TWFueSIsImtleXMiLCJmb3JFYWNoIiwiayIsInJlZHVjZSIsImFjYyIsImN1cnJlbnQiLCJ2YWwiLCJzZXRNYW55IiwidmFsdWVzIiwia2V5VmFsdWUiLCJPYmplY3QiLCJ2YWx1ZXNBcnJheSIsIm1hcCIsImVudHJ5IiwicmVtb3ZlU2luZ2xlIiwibXVsdGlSZW1vdmUiLCJyZW1vdmVNYW55IiwiZ2V0S2V5cyIsImdldEFsbEtleXMiLCJlcnIiLCJkcm9wU3RvcmFnZSIsImNsZWFyIiwiZXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFRQTs7Ozs7O0FBUUEsU0FBU0EsYUFBVCxDQUF1QkMsSUFBdkIsRUFBb0Q7QUFDbEQsTUFBSSxDQUFDQSxJQUFMLEVBQVc7QUFDVCxXQUFPLElBQVA7QUFDRDs7QUFDRCxTQUFPQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsSUFBZCxJQUFzQkEsSUFBSSxDQUFDRyxNQUFMLENBQVlDLENBQUMsSUFBSSxDQUFDLENBQUNBLENBQW5CLENBQXRCLEdBQThDLENBQUNKLElBQUQsQ0FBckQ7QUFD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UDtBQWNEOztBQUVELFFBQU1vQixXQUFOLENBQWtCOUIsQ0FBbEIsRUFBcUQ7QUFDbkQsV0FBTyxJQUFJQyxPQUFKLENBQWtCLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUM1QyxXQUFLVCx5QkFBTCxDQUErQnFDLEtBQS9CLENBQXFDLFVBQ25DQyxLQURtQyxFQUVuQztBQUNBLGNBQU1ILEdBQUcsR0FBR3BELGFBQWEsQ0FBQ3VELEtBQUQsQ0FBekI7O0FBQ0EsWUFBSUgsR0FBSixFQUFTO0FBQ1AxQixVQUFBQSxNQUFNLENBQUMwQixHQUFELENBQU47QUFDRCxTQUZELE1BRU87QUFDTDNCLFVBQUFBLE9BQU87QUFDUjtBQUNGLE9BVEQ7QUFVRCxLQVhNLENBQVA7QUFZRDs7QUF2TDZCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFJlYWN0IE5hdGl2ZSBDb21tdW5pdHkuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7TmF0aXZlTW9kdWxlc30gZnJvbSAncmVhY3QtbmF0aXZlJztcbmltcG9ydCB7XG4gIEVtcHR5U3RvcmFnZU1vZGVsLFxuICBJU3RvcmFnZUJhY2tlbmQsXG4gIFN0b3JhZ2VPcHRpb25zLFxufSBmcm9tICdAcmVhY3QtbmF0aXZlLWNvbW11bml0eS9hc3luYy1zdG9yYWdlJztcbmltcG9ydCB7SUxlZ2FjeU5hdGl2ZU1vZHVsZX0gZnJvbSAnLi4vdHlwZXMvbmF0aXZlTW9kdWxlJztcblxuZnVuY3Rpb24gY29udmVydEVycm9ycyhlcnJzPzogQXJyYXk8RXJyb3I+IHwgRXJyb3IpIHtcbiAgaWYgKCFlcnJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXJycykgPyBlcnJzLmZpbHRlcihlID0+ICEhZSkgOiBbZXJyc107XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsaWRJbnB1dCh1c2VkS2V5OiBhbnksIHZhbHVlPzogYW55KSB7XG4gIGNvbnN0IGlzVmFsdWVQYXNzZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMTtcblxuICBpZiAodHlwZW9mIHVzZWRLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFtBc3luY1N0b3JhZ2VMZWdhY3ldIFVzaW5nIFwiJHt0eXBlb2YgdXNlZEtleX1cIiB0eXBlIGZvciBrZXkgaXMgbm90IHN1cHBvcnRlZC4gVGhpcyBjYW4gbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yL2Vycm9ycy4gVXNlIHN0cmluZyBpbnN0ZWFkLlxcbktleSBwYXNzZWQ6ICR7dXNlZEtleX1cXG5gLFxuICAgICk7XG4gIH1cblxuICBpZiAoaXNWYWx1ZVBhc3NlZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFtBc3luY1N0b3JhZ2VMZWdhY3ldIFBhc3NpbmcgXCJudWxsXCIgb3IgXCJ1bmRlZmluZWRcIiBhcyB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0byByZW1vdmUgYSB2YWx1ZSwgdXNlIFwiLnJlbW92ZVNpbmdsZVwiIG1ldGhvZCBpbnN0ZWFkLlxcblVzZWQga2V5OiAke3VzZWRLZXl9XFxuYCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtBc3luY1N0b3JhZ2VMZWdhY3ldIFRoZSB2YWx1ZSBmb3Iga2V5IFwiJHt1c2VkS2V5fVwiIGlzIG5vdCBhIHN0cmluZy4gVGhpcyBjYW4gbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yL2Vycm9ycy4gQ29uc2lkZXIgc3RyaW5naWZ5aW5nIGl0LlxcblBhc3NlZCB2YWx1ZTogJHt2YWx1ZX1cXG5QYXNzZWQga2V5OiAke3VzZWRLZXl9XFxuYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExlZ2FjeUFzeW5jU3RvcmFnZTxcbiAgVCBleHRlbmRzIEVtcHR5U3RvcmFnZU1vZGVsID0gRW1wdHlTdG9yYWdlTW9kZWxcbj4gaW1wbGVtZW50cyBJU3RvcmFnZUJhY2tlbmQ8VD4ge1xuICBwcml2YXRlIHJlYWRvbmx5IF9hc3luY1N0b3JhZ2VOYXRpdmVNb2R1bGU6IElMZWdhY3lOYXRpdmVNb2R1bGU7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYXN5bmNTdG9yYWdlTmF0aXZlTW9kdWxlID1cbiAgICAgIE5hdGl2ZU1vZHVsZXMuUk5DX0FzeW5jU1FMaXRlREJTdG9yYWdlIHx8IE5hdGl2ZU1vZHVsZXMuUk5DQXN5bmNTdG9yYWdlO1xuXG4gICAgaWYgKCF0aGlzLl9hc3luY1N0b3JhZ2VOYXRpdmVNb2R1bGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1tAUk5DL0FzeW5jU3RvcmFnZV06IE5hdGl2ZU1vZHVsZTogQXN5bmNTdG9yYWdlIGlzIG51bGwuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0U2luZ2xlPEsgZXh0ZW5kcyBrZXlvZiBUPihcbiAgICBrZXk6IEssXG4gICAgXz86IFN0b3JhZ2VPcHRpb25zLFxuICApOiBQcm9taXNlPFRbS10gfCBudWxsPiB7XG4gICAgY2hlY2tWYWxpZElucHV0KGtleSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fYXN5bmNTdG9yYWdlTmF0aXZlTW9kdWxlLm11bHRpR2V0KFtrZXldLCBmdW5jdGlvbihcbiAgICAgICAgZXJyb3JzOiBBcnJheTxFcnJvcj4sXG4gICAgICAgIHJlc3VsdDogQXJyYXk8W2FueSwgVFtLXSB8IG51bGxdPixcbiAgICAgICkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChyZXN1bHQgJiYgcmVzdWx0WzBdICYmIHJlc3VsdFswXVsxXSkgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgZXJycyA9IGNvbnZlcnRFcnJvcnMoZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycnMgJiYgZXJycy5sZW5ndGgpIHtcbiAgICAgICAgICByZWplY3QoZXJyc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2V0U2luZ2xlPEsgZXh0ZW5kcyBrZXlvZiBUPihcbiAgICBrZXk6IEssXG4gICAgdmFsdWU6IFRbS10sXG4gICAgXz86IFN0b3JhZ2VPcHRpb25zLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjaGVja1ZhbGlkSW5wdXQoa2V5LCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fYXN5bmNTdG9yYWdlTmF0aXZlTW9kdWxlLm11bHRpU2V0KFtba2V5LCB2YWx1ZV1dLCBmdW5jdGlvbihcbiAgICAgICAgZXJyb3JzOiBBcnJheTxFcnJvcj4sXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZXJycyA9IGNvbnZlcnRFcnJvcnMoZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycnMgJiYgZXJycy5sZW5ndGgpIHtcbiAgICAgICAgICByZWplY3QoZXJyc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldE1hbnk8SyBleHRlbmRzIGtleW9mIFQ+KFxuICAgIGtleXM6IEFycmF5PEs+LFxuICAgIF8/OiBTdG9yYWdlT3B0aW9ucyxcbiAgKTogUHJvbWlzZTx7W2sgaW4gS106IFRba10gfCBudWxsfT4ge1xuICAgIGtleXMuZm9yRWFjaChrID0+IGNoZWNrVmFsaWRJbnB1dChrKSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fYXN5bmNTdG9yYWdlTmF0aXZlTW9kdWxlLm11bHRpR2V0KGtleXMsIGZ1bmN0aW9uKFxuICAgICAgICBlcnJvcnM6IEFycmF5PEVycm9yPixcbiAgICAgICAgcmVzdWx0OiBBcnJheTxbSywgVFtLXV0+LFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlOiB7W2sgaW4gS106IFRba119ID0gcmVzdWx0LnJlZHVjZTxhbnk+KFxuICAgICAgICAgIChhY2MsIGN1cnJlbnQ6IFtLLCBUW0tdXSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY3VycmVudFswXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgIFtrZXldOiB2YWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAge30sXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGVycnMgPSBjb252ZXJ0RXJyb3JzKGVycm9ycyk7XG4gICAgICAgIGlmIChlcnJzICYmIGVycnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVqZWN0KGVycnNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNldE1hbnk8SyBleHRlbmRzIGtleW9mIFQ+KFxuICAgIHZhbHVlczogQXJyYXk8UGFydGlhbDx7W2sgaW4gS106IFRba119Pj4sXG4gICAgXz86IFN0b3JhZ2VPcHRpb25zLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB2YWx1ZXMuZm9yRWFjaChrZXlWYWx1ZSA9PiB7XG4gICAgICAoT2JqZWN0LmtleXMoa2V5VmFsdWUpIGFzIEFycmF5PEs+KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNoZWNrVmFsaWRJbnB1dChrZXksIGtleVZhbHVlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzQXJyYXkgPSB2YWx1ZXMubWFwKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMoZW50cnkpWzBdIGFzIEs7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZW50cnlba2V5XTtcblxuICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9hc3luY1N0b3JhZ2VOYXRpdmVNb2R1bGUubXVsdGlTZXQodmFsdWVzQXJyYXksIGZ1bmN0aW9uKFxuICAgICAgICBlcnJvcnM6IEFycmF5PEVycm9yPixcbiAgICAgICkge1xuICAgICAgICBjb25zdCBlcnJzID0gY29udmVydEVycm9ycyhlcnJvcnMpO1xuICAgICAgICBpZiAoZXJycyAmJiBlcnJzLmxlbmd0aCkge1xuICAgICAgICAgIHJlamVjdChlcnJzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVtb3ZlU2luZ2xlKGtleToga2V5b2YgVCwgXz86IFN0b3JhZ2VPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2hlY2tWYWxpZElucHV0KGtleSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fYXN5bmNTdG9yYWdlTmF0aXZlTW9kdWxlLm11bHRpUmVtb3ZlKFtrZXldLCBmdW5jdGlvbihcbiAgICAgICAgZXJyb3JzOiBBcnJheTxFcnJvcj4sXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZXJycyA9IGNvbnZlcnRFcnJvcnMoZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycnMgJiYgZXJycy5sZW5ndGgpIHtcbiAgICAgICAgICByZWplY3QoZXJyc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlbW92ZU1hbnkoa2V5czogQXJyYXk8a2V5b2YgVD4sIF8/OiBTdG9yYWdlT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGtleXMuZm9yRWFjaChrID0+IGNoZWNrVmFsaWRJbnB1dChrKSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fYXN5bmNTdG9yYWdlTmF0aXZlTW9kdWxlLm11bHRpUmVtb3ZlKGtleXMsIGZ1bmN0aW9uKFxuICAgICAgICBlcnJvcnM6IEFycmF5PEVycm9yPixcbiAgICAgICkge1xuICAgICAgICBjb25zdCBlcnJzID0gY29udmVydEVycm9ycyhlcnJvcnMpO1xuICAgICAgICBpZiAoZXJycyAmJiBlcnJzLmxlbmd0aCkge1xuICAgICAgICAgIHJlamVjdChlcnJzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZ2V0S2V5cyhfPzogU3RvcmFnZU9wdGlvbnMpOiBQcm9taXNlPEFycmF5PGtleW9mIFQ+PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2FzeW5jU3RvcmFnZU5hdGl2ZU1vZHVsZS5nZXRBbGxLZXlzKGZ1bmN0aW9uKFxuICAgICAgICBlcnJvcnM6IEFycmF5PEVycm9yPixcbiAgICAgICAga2V5czogQXJyYXk8a2V5b2YgVD4sXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZXJyID0gY29udmVydEVycm9ycyhlcnJvcnMpO1xuXG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmxlbmd0aCkge1xuICAgICAgICAgIHJlamVjdChlcnJbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoa2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZHJvcFN0b3JhZ2UoXz86IFN0b3JhZ2VPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2FzeW5jU3RvcmFnZU5hdGl2ZU1vZHVsZS5jbGVhcihmdW5jdGlvbihcbiAgICAgICAgZXJyb3I6IEFycmF5PEVycm9yPiB8IEVycm9yLFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IGNvbnZlcnRFcnJvcnMoZXJyb3IpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIl19